# Webhooks

## Webhook Subscriptions

## Retry Policy
 
## Universal Webhook

The universal webhook fires on any change to a reservation you own (including related resource changes such as customer, invoice and payments).

The payload you receive contains:

```json
{
    "signature":
    {
        "timestamp": 1600876661,
        "token": "9d6bdaa2-fcd0-415a-8a6d-d5c3356cbde4",
        "signature": "c60f7704417c09d7b07fe2a371b5d946323205ed1ecce3c11af7d546f3c4d510"
    },
    "id": 12345,
    "event": "order_new",
    "resort": {
        "id": 1,
        "name": "Pitchfork Ranch",
        "slug_name": "pitchfork-ranch"
    }
}
```

*   An object named ‘signature’ you will be able to use to verify the request is coming from us
*   The Id of the reservation that changed, so you can send a query to the Reservation Status endpoint and get the latest info.
*   The event that caused the webhook to fire
*   The resort which the reservation belongs to, so you can use the right access token when calling into the api to get the data.

The 'signature' object contains:

Key | Type | Description
--------- | ------- | -----------
timestamp | Integer | Number of seconds passed since January 1, 1970.
token | String | a randomly generated string of 36 characters (a version 4 UUID)
signature | String | String of hexadecimal digits generated by the HMAC algorithm

### Securing the Universal Webhook

```python
import hashlib, hmac

def verify(signing_key, token, timestamp, signature):
    hmac_digest = hmac.new(key=signing_key.encode(),
                           msg=('{}{}'.format(timestamp, token)).encode(),
                           digestmod=hashlib.sha256).hexdigest()
    return hmac.compare_digest(str(signature), str(hmac_digest))
```

```ruby
require 'openssl'

def verify(signing_key, token, timestamp, signature)
  digest = OpenSSL::Digest::SHA256.new
  data = [timestamp, token].join
  signature == OpenSSL::HMAC.hexdigest(digest, signing_key, data)
end
```

```javascript
const crypto = require('crypto')

const verify = ({ signingKey, timestamp, token, signature }) => {
    const encodedToken = crypto
        .createHmac('sha256', signingKey)
        .update(timestamp.concat(token))
        .digest('hex')

    return (encodedToken === signature)
}
```

To generate the signature for comparison against the one we sent along, you need to:

* Concatenate the timestamp and token.
* Encode that message with the HMAC algorithm, using your application's Client Secret as the key and SHA256 as the digest mode.
* Compare that hexdigest to the signature.

Consider caching the token value locally and not honoring any subsequent request with the same token to protect against replay attacks.
